## 设计文档

---

##### 一、实现思路

使用GNU编译套件作为接收编译、运行的主要工具。其中GCC工具主要用于源代码的编译，并添加相应的调试信息，GDB则负责以虚拟的形式运行程序，获取程序的内存信息，提供例如添加断点、单步、步入等调试功能。

服务端实现用户的登录、以及与创建与GDB,GCC工具连接的会话层，并解析GDB-MI格式指令的输出，将解析的结果以JSON格式，按照自定的进行返回，并提供诸如代码上传、编译、调试、示例发布、示例管理、多媒体附件上传、记录等接口，供前端调用。

前端则负责程序内存信息、运行信息、用户交互部分功能，并能实现在线录音上传，断点添加等相应的功能，使得交互逻辑更加完善，提供较为合理的页面。

---

##### 二、系统结构

###### 1.GDB会话管理

服务端需要与GDB程序进行交互，发送指令和获取指令的返回，这个过程是交互的，这个过程成为机器交互。即需要一个程序取操作、影响另外一个程序，这个操作过程仅靠简单的输入输出重定向是无法实现的，这是一个IPC问题，可选的技术有：Linux下的管道机制、伪终端pty技术。

管道技术是IPC的简单的逻辑，通常用于两个进程之间的信息交互，可以用来实现交互，实现较为简单，但是管道的缓冲区大小是固定的，在大批量的数据交互上并不占优。未采用该技术。

伪终端pty技术，该技术类似于管道技术，但是其提供了更完善的功能，不用去管理缓冲区的大小，和传输数据的一些问题。其核心思想是主进程在创建子进程时，为其创建一个虚拟的中断，主进程和子进程都可对该终端进行交互，并传输信息，这与我们实现机器控制的思想是相同，因此采用该技术。

在程序运行时，我们不仅要与GDB交互，还要与被运行、被调试的程序进行交互，因此我们仍需要另外一个pty专门与被运行、被调试的程序进行交互。部分时候我们还需采集原GDB而非GDB-MI程序的输出，因此在GDB会话管理的层面上，我们对于每个会话均需要三个伪终端，并且实现终端的读取、写入、退出等相应的操作，便于我们后续的开发。

因此，在本处的实现中，首先封装了Pty类，负责伪终端的创建，读、写、关闭等操作，便于实现对伪终端的操作。在实现Pty类时，使用了select技术实现非阻塞IO，解决在交互过程中出现的阻塞现象。

实现Pty类后，使用Pty类继续封装，封装为GDBSession，实现了整个会话管理类，其主要包含上述的三个伪终端，以及其对应的GDB的pid等信息。以及一些负责执行、操作命令的api函数。

---

###### 2.GDB-MI的解析

在于GDB进行交互的过程中，需要解析GDB的输出，其中GDB-MI是GDB专门面向机器交互开发的交互接口，其提供了较为容易解析的指令输出，可以用来实现机器交互。在此不做过多的叙述。

GDB-MI的解析模块主要包括三个模块：

* 首先是unescape模块，GDB-MI的输出是带有转义字符的输出，例如：<kbd>Enter</kbd>在GDB-MI中的输出为`"\n"`，在第一步的处理中，我们首先要将这些转义字符重新修正为其原本的含义，方便后续进行解析处理。

* 其次就是parser模块，该模块主要负责解析经过unescape的GDB-MI响应的解析。其基本思路为，首先通过正则表达式对输出信息的类型进行判断，然后调用相应的方法，对其内容进行进一步解析，主要用到的两个方法为：解析文本中的字典、解析文本中的数组。这两个方法在使用中占据了大部分，因为我们在使用GDB-MI更多的是获取程序中变量的值，程序的运行状态等信息。其呈现方式为字典和列表的形式。

* 最后就是io管理模块iomanager，该模块是用来与第一个板块中介绍的GDBSession进行连接和耦合的模块，将负责与GDB交互的伪终端的标准输入和输出传递给iomanager，使用其将解析模块和会话模块进行耦合，并再次封装成更为易用、简明的GDB会话窗口。

解析后的信息格式为：

* type：返回信息的类型，有六种，notify（调试过程中的通知），result（指令执行的结果），console（命令行的输出），target（目标程序的输出），log（GDB输出的日志信息），done（指令是否完成的反馈信息），output（GDB的输出）

* message：返回信息的消息，例如：当遇到断点程序停止运行时，该值为stoped

* payload：承载主要信息的部分，大部分信息以字典、列表的形式存放，例如：变量的名和值，当前堆栈的情况，等等

* token：GDB-MI指令输入时可以在指令首部添加一个数字用来表示当前的序号，指令返回时也会带有该序号。

---

###### 3.用户会话的管理

该系统为在线系统，需要支持多用户，因此我们需要能够表示每个用户，并为每个用户均分配一个调试、运行的会话。因此我们需要设计会话管理的类，在项目中是以SessionManager的类存在的，该类用于管理每个用户所拥有的会话。

介绍SessionManager首先需要了解WebSocket，http请求时一种单方的通信，只允许用户主动向服务器发送消息，而服务器不能主动发送消息。因此仅仅通过http请求无法实现我们所涉及的功能。考虑如下一种场景：我们给待调试的程序添加了断点，但是运行到下一个断点需要2s的时间，如果使用http请求，在我们点击运行之后服务器就应当给出响应，但是此时我们的结果还没得出，无法返回结果，后续得到运行结果后服务器也不能主动发送给用户。因此单单使用http请求是无法实现所设计的功能，故在这里选用了WebSocket协议，服务器也可主动发送消息，便于我们实现异步通信。

对于WebSocket来讲，创立连接后服务器会生成一份唯一的用户id，这里称为sid，通过sid可以标识每一名用户，也即是该特点，我们能够设计出会话管理的类，负责管理每位用户的会话。

在本项目中，会话管理类设计的功能较多，方便后续的二次开发，在目前的项目中主要使用到了添加新的会话、删除会话、读取每个会话的响应并解析发送给相应的用户。值得一提的是，会话管理还设计了加入某个会话的功能，这个功能能够用来设计共同调试的功能，但因作者实力、阅历、经验有限，目前尚未进行开发。

---

###### 4.服务端

在上述的类与结构设计完成并实现之后，便可在服务端设计相应的http请求的响应，WebSocket请求的响应。添加相应的逻辑实现较为多样的功能，截至目前为止实现的功能，在上次的汇报中已经有写道，再次不做赘述。

值得一提的是，服务端的数据库的设计，在这里设计的数据库较为简单，进行二次开发时可着重考虑数据库关系的设计，利用已经封装好的会话类实现更佳丰富的内容。在本项目中数据库分为两个表，一个表记录用户的信息：账号，密码，工作文件的路径。另外一张表记录已经发布的示例，其记录的内容为：发布示例的用户的账号、示例的名称、示例的摘要、示例存放的地址，方便用户学习示例时的拉取。

在本项目中，用户上传以及添加的多媒体附件并没有使用单独的数据库记录，而是使用文件名+文件行号+.asset的形式进行记录，当用户将当前的工作目录打包发布时，多媒体附件也会打包发布，但是多媒体附件默认不可见，在程序调试和执行的过程中有相应的逻辑对多媒体附件进行相应的处理、获取、展示。

---

###### 5.前端

前端的页面设计的较为简单，主要包括以下部分：

* 文件树：用于管理文件，创建、删除新的代码文件，并且支持本地文件的拖拽上传。

* 代码编辑器：用于用户在线编辑代码，调试时添加代码，编译错误时提示编译错误的行号，调试时聚焦当前运行的代码。

* 堆栈展示区域：用于展示程序运行过程中的堆栈内容，包括当前堆栈的的函数名、参数。局部变量的参数。每个栈帧都可以进行展开、关闭的操作，还设计了指针的等变量的对应，野指针的检测。

* 程序交互区域：用于用户与被运行、被调试的程序进行交互，例如输入，输出。

* 全局变量区域：展示当前运行过程中的全局变量。

* 编译信息/附件展示区域：程序处于编辑阶段时，此处展示编译信息，当程序运行时，此处展示是否有添加的附件信息，附件支持图片、文字、录音、视频展现形式。

前端负责的功能就是与后端http，WebSocket设计的逻辑进行交互，利用开发的会话API以及返回的数据进行丰富的动画展示和创新功能的开发。在此不做过多的叙述。
